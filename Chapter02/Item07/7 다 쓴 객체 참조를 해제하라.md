# 7. 다 쓴 객체 참조를 해제하라

C, C++처럼 메모리를 직접 관리해야 하는 언어를 쓰다가 자바처럼 가비지 컬렉터를 갖춘 언어로 넘어오면 프로그래머의 삶이 훨씬 평안해진다. 다 쓴 객체를 알아서 회수해가기 때문이다.

**⇒ 하지만 메모리 관리를 더 이상 신경 쓰지 않아도 된다는 것은 아니다.**

- 메모리 누수가 발생할 수 있는 코드
    
    ```java
    public class Stack {
        private Object[] elements;
        private int size = 0;
        private static final int DEFAULT_INITIAL_CAPACITY = 16;
    
        public Stack() {
            elements = new Object[DEFAULT_INITIAL_CAPACITY];
        }
    
        public void push(Object e) {
            ensureCapacity();
            elements[size++] = e;
        }
    
        public Object pop() {
            if (size == 0) {
                throw new EmptyStackException();
            }
            return elements[--size];
        }
    
        private void ensureCapacity() {
            if (elements.length == size) {
                elements = Arrays.copyOf(elements, 2 * size + 1);
            }
        }
    }
    ```
    
    - pop() 메서드는 스택에서 요소를 꺼내지만, 배열 elements에는 여전히 그 객체에 대한 참조가 남아 있다.
    - 이로 인해 메모리 누수가 발생할 수 있다.

- 다 쓴 객체 참조 해제
    
    ```java
     public Object pop() {
            if (size == 0) {
                throw new EmptyStackException();
            }
            Object result = elements[--size];
            elements[size] = null; // 다 쓴 객체 참조 해제
            return result;
        }
    ```
    
    - pop() 메서드에서 다 쓴 객체에 대한 참조를 null로 설정하여 해제한다.
    - 이로 인해 가비지 컬렉터는 더 이상 사용되지 않는 객체를 회수할 수 있다.

    <Br>
💡 **객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.**



- 예외적인 경우가 무엇인가? (=객체 참조를 명시적으로 null로 설정해야 하는 예외적인 경우)
    - **장기간 유지되는 컬렉션**: 장기간동안 유지되는 컬렉션을 사용하고, 해당 컬렉션이 포함된 객체가 더 이상 필요하지 않을 때
    - **명시적인 리소스 해제**: 데이터베이스 연결, 파일 핸들러, 네트워크 소켓 등과 같은 시스템 리소스를 사용하는 객체를 명시적으로 해제할 때
    - **메모리 누수 방지**: 클래스가 자신의 내부에서 다수의 객체를 참조하는 경우, 특히 그 객체들이 더 이상 사용되지 않음에도 불구하고 참조가 유지되는 경우
- 왜 예외적인 경우여야 하는가?
    - **가비지 컬렉터의 역할**: 가비지 컬렉터는 더 이상 참조되지 않는 객체를 자동으로 회수하여 메모리를 관리한다. 일반적으로 객체 참조를 명시적으로 null로 설정할 필요가 없다.
    - **코드의 가독성**: 객체 참조를 명시적으로 null로 설정하면 코드의 가독성과 유지보수성이 떨어진다.
    - **객체 생명주기 관리**: 객체의 생명주기는 코드의 구조와 범위에 의해 자연스럽게 관리된다.

    <Br>
💡 **자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야 한다.**


<Br>

💡 **캐시 역시 메모리 누수를 일으키는 주범이다.**

> 캐시: 자주 참조되는 데이터를 저장하여 접근 속도를 높이기 위한 임시 저장 공간
> 


- **오래된 데이터 유지**
    - 캐시에 저장된 데이터가 오래되었음에도 불구하고 여전히 캐시에 남아있을 때, 이 데이터가 실제로는 더 이상 사용되지 않더라도 메모리를 차지하게 된다.
- **무한히 증가하는 데이터**
    - 캐시 크기에 제한이 없거나, 제한이 충분히 설정되지 않은 경우, 캐시가 계속해서 새로운 데이터를 받아들여 메모리가 무한히 증가할 수 있다.
- **부적절한 삭제 전략**
    - 캐시가 데이터를 삭제하는 전략이 적절하지 않으면, 더 이상 필요하지 않는 데이터가 계속해서 캐시에 남아 있을 수 있다.